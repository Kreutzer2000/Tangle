"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
exports.__esModule = true;
var riteway_1 = require("riteway");
var errors = require("../../errors");
var transaction_1 = require("../src/transaction");
var converter_1 = require("@iota/converter");
var pad_1 = require("@iota/pad");
var samples_1 = require("@iota/samples");
var transactionObject = samples_1.bundle[0];
var transaction = converter_1.trytesToTrits(samples_1.bundleTrytes[0]);
var transactionBuffer = new Int8Array(transaction_1.TRANSACTION_LENGTH * 2);
var offset = transaction_1.TRANSACTION_LENGTH;
transactionBuffer.set(transaction, offset);
var transactionWithInvalidAddress = converter_1.trytesToTrits(samples_1.bundleTrytes[0]);
var transactionWithInvalidAddressB = converter_1.trytesToTrits(samples_1.bundleTrytes[1]);
var minWeightMagnitude = 14;
var addressTrits = transaction_1.address(transactionWithInvalidAddress);
var addressTritsB = transaction_1.address(transactionWithInvalidAddressB);
addressTrits[transaction_1.ADDRESS_LENGTH - 1] = 1;
addressTritsB[transaction_1.ADDRESS_LENGTH - 1] = 1;
transactionWithInvalidAddress.set(addressTrits, transaction_1.ADDRESS_OFFSET);
transactionWithInvalidAddressB.set(addressTritsB, transaction_1.ADDRESS_OFFSET);
var expectedSignatureOrMessage = converter_1.trytesToTrits(transactionObject.signatureMessageFragment);
var expectedAddress = converter_1.trytesToTrits(transactionObject.address);
var expectedValue = transactionObject.value;
var expectedObsoleteTag = converter_1.trytesToTrits(transactionObject.obsoleteTag);
var expectedIssuanceTimestamp = transactionObject.timestamp;
var expectedCurrentIndex = transactionObject.currentIndex;
var expectedLastIndex = transactionObject.lastIndex;
var expectedBundle = converter_1.trytesToTrits(transactionObject.bundle);
var expectedTrunkTransaction = converter_1.trytesToTrits(transactionObject.trunkTransaction);
var expectedBranchTransaction = converter_1.trytesToTrits(transactionObject.branchTransaction);
var expectedTag = converter_1.trytesToTrits(transactionObject.tag);
var expectedAttachmentTimestamp = transactionObject.attachmentTimestamp;
var expectedAttachmentTimestampLowerBound = transactionObject.attachmentTimestampLowerBound;
var expectedAttachmentTimestampUpperBound = transactionObject.attachmentTimestampUpperBound;
var expectedTransactionNonce = converter_1.trytesToTrits(transactionObject.nonce);
var expectedTransactionEssence = converter_1.trytesToTrits([
    transactionObject.address,
    converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.VALUE_LENGTH)(converter_1.valueToTrits(transactionObject.value))),
    converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.OBSOLETE_TAG_LENGTH)(converter_1.trytesToTrits(transactionObject.obsoleteTag))),
    converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.ISSUANCE_TIMESTAMP_LENGTH)(converter_1.valueToTrits(transactionObject.timestamp))),
    converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.CURRENT_INDEX_LENGTH)(converter_1.valueToTrits(transactionObject.currentIndex))),
    converter_1.tritsToTrytes(pad_1.padTrits(transaction_1.LAST_INDEX_LENGTH)(converter_1.valueToTrits(transactionObject.lastIndex))),
].join(''));
riteway_1.describe('isMultipleOfTransactionLength(lengthOrOffset: number): boolean', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'lengthOrOffset = undefined',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.isMultipleOfTransactionLength, undefined),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'lengthOrOffset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.isMultipleOfTransactionLength, NaN),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'lengthOrOffset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.isMultipleOfTransactionLength, null),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'lengthOrOffset = "1" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.isMultipleOfTransactionLength, (transaction_1.TRANSACTION_LENGTH * 3).toString()),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'lengthOrOffset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.isMultipleOfTransactionLength, Infinity),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'lengthOrOffset < 0',
            should: 'return false',
            actual: transaction_1.isMultipleOfTransactionLength(-transaction_1.TRANSACTION_LENGTH),
            expected: false
        });
        assert({
            given: 'lengthOrOffset < 0',
            should: 'return false',
            actual: transaction_1.isMultipleOfTransactionLength(-transaction_1.TRANSACTION_LENGTH),
            expected: false
        });
        assert({
            given: 'lengthOrOffset that is not multiple of TRANSACTION_SIZE',
            should: 'return false',
            actual: transaction_1.isMultipleOfTransactionLength(1),
            expected: false
        });
        assert({
            given: 'lengthOrOffset that is multiple of TRANSACTION_SIZE',
            should: 'return true',
            actual: transaction_1.isMultipleOfTransactionLength(transaction_1.TRANSACTION_LENGTH * 3),
            expected: true
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('transactionBufferSlice(transactionFieldOffset: number, transactionFieldLength: number): (transactionBuffer: Int8Array, transactionBufferOffset = 0) => Int8Array', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionFieldOffset = undefined',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, undefined, 1),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldOffset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, NaN, 1),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldOffset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, null, 1),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldOffset = "1" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, '1', 1),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldOffset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, Infinity, 1),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldOffset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, -1, 1),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET)
        });
        assert({
            given: 'transactionFieldLength = undefined',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, undefined),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionFieldLength = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionFieldLength = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionFieldLength = "1" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, '1'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionFieldLength = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionFieldLength < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice, 0, -1),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH)
        });
        assert({
            given: 'transactionBuffer = undefined',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), undefined),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_BUFFER)
        });
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'transactionBufferOffset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(transactionBufferSlice(0, 1), new Int8Array(TRANSACTION_LENGTH), undefined as any),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'transactionBufferOffset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH), NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'transactionBufferOffset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH), null),
            expected: new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET)
        });
        assert({
            given: 'transactionBufferOffset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH), '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'transactionBufferOffset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH), Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'transactionBufferOffset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionBufferSlice(0, 1), new Int8Array(transaction_1.TRANSACTION_LENGTH), -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and transactionBufferOffset = 0',
            should: 'return the correct slice',
            actual: transaction_1.transactionBufferSlice(0, 1)(new Int8Array(transaction_1.TRANSACTION_LENGTH).map(function (trit, i) { return (i === 0 ? 1 : 0); }), 0),
            expected: new Int8Array(1).fill(1)
        });
        assert({
            given: 'valid transactionBuffer and valid transactionBufferOffset',
            should: 'return the correct slice',
            actual: transaction_1.transactionBufferSlice(0, 1)(new Int8Array(transaction_1.TRANSACTION_LENGTH * 2).map(function (trit, i) { return (i === transaction_1.TRANSACTION_LENGTH ? 1 : trit); }), transaction_1.TRANSACTION_LENGTH),
            expected: new Int8Array(1).fill(1)
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('signatureOrMessage(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(signatureOrMessage, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.signatureOrMessage, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct signature or message',
            actual: transaction_1.signatureOrMessage(transaction),
            expected: expectedSignatureOrMessage
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct signature or message',
            actual: transaction_1.signatureOrMessage(transactionBuffer, offset),
            expected: expectedSignatureOrMessage
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('address(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.address, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(address, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.address, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.address, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.address, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.address, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.address, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct address',
            actual: transaction_1.address(transaction),
            expected: expectedAddress
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct address',
            actual: transaction_1.address(transactionBuffer, offset),
            expected: expectedAddress
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('value(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.value, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(value, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.value, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.value, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.value, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.value, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.value, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct value',
            actual: converter_1.tritsToValue(transaction_1.value(transaction)),
            expected: expectedValue
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct value',
            actual: converter_1.tritsToValue(transaction_1.value(transactionBuffer, offset)),
            expected: expectedValue
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('obsoleteTag(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var obsoleteTag;
    return __generator(this, function (_a) {
        obsoleteTag = transaction_1.createObsoleteTag(true);
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(obsoleteTag, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(obsoleteTag, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(obsoleteTag, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(obsoleteTag, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(obsoleteTag, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(obsoleteTag, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(obsoleteTag, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct obsoletTag',
            actual: obsoleteTag(transaction),
            expected: expectedObsoleteTag
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct obsoleteTag',
            actual: obsoleteTag(transactionBuffer, offset),
            expected: expectedObsoleteTag
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('issuanceTimestamp(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(issuanceTimestamp, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.issuanceTimestamp, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct issuanceTimestamp',
            actual: converter_1.tritsToValue(transaction_1.issuanceTimestamp(transaction)),
            expected: expectedIssuanceTimestamp
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct issuanceTimestamp',
            actual: converter_1.tritsToValue(transaction_1.issuanceTimestamp(transactionBuffer, offset)),
            expected: expectedIssuanceTimestamp
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('currentIndex(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var currentIndex;
    return __generator(this, function (_a) {
        currentIndex = transaction_1.createCurrentIndex(true);
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(currentIndex, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(currentIndex, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(currentIndex, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(currentIndex, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(currentIndex, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(currentIndex, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(currentIndex, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct currentIndex',
            actual: converter_1.tritsToValue(currentIndex(transaction)),
            expected: expectedCurrentIndex
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct currentIndex',
            actual: converter_1.tritsToValue(currentIndex(transactionBuffer, offset)),
            expected: expectedCurrentIndex
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('lastIndex(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var lastIndex;
    return __generator(this, function (_a) {
        lastIndex = transaction_1.createLastIndex(true);
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(lastIndex, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(lastIndex, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(lastIndex, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(lastIndex, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(lastIndex, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(lastIndex, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(lastIndex, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct lastIndex',
            actual: converter_1.tritsToValue(lastIndex(transaction)),
            expected: expectedLastIndex
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct lastIndex',
            actual: converter_1.tritsToValue(lastIndex(transactionBuffer, offset)),
            expected: expectedLastIndex
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('bundle(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var bundle;
    return __generator(this, function (_a) {
        bundle = transaction_1.createBundle(true);
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(bundle, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(bundle, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(bundle, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(bundle, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(bundle, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(bundle, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(bundle, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct bundle',
            actual: bundle(transaction),
            expected: expectedBundle
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct bundle',
            actual: bundle(transactionBuffer, offset),
            expected: expectedBundle
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('trunkTransaction(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(trunkTransaction, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.trunkTransaction, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct trunkTransaction',
            actual: transaction_1.trunkTransaction(transaction),
            expected: expectedTrunkTransaction
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct trunkTransaction',
            actual: transaction_1.trunkTransaction(transactionBuffer, offset),
            expected: expectedTrunkTransaction
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('branchTransaction(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(value, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.branchTransaction, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct branchTransaction',
            actual: transaction_1.branchTransaction(transaction),
            expected: expectedBranchTransaction
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct branchTransaction',
            actual: transaction_1.branchTransaction(transactionBuffer, offset),
            expected: expectedBranchTransaction
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('tag(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.tag, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(tag, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.tag, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.tag, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.tag, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.tag, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.tag, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct tag',
            actual: transaction_1.tag(transaction),
            expected: expectedTag
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct tag',
            actual: transaction_1.tag(transactionBuffer, offset),
            expected: expectedTag
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('attachmentTimestamp(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(attachmentTimestamp, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestamp, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct attachmentTimestamp',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestamp(transaction)),
            expected: expectedAttachmentTimestamp
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct attachmentTimestamp',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestamp(transactionBuffer, offset)),
            expected: expectedAttachmentTimestamp
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('attachmentTimestampLowerBound(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(attachmentTimestampLoweBound, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampLowerBound, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct attachmentTimestampLowerBound',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestampLowerBound(transaction)),
            expected: expectedAttachmentTimestampLowerBound
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct attachmentTimestampLowerBound',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestampLowerBound(transactionBuffer, offset)),
            expected: expectedAttachmentTimestampLowerBound
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('attachmentTimestampUpperBound(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(attachmentTimestampLoweBound, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.attachmentTimestampUpperBound, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct attachmentTimestampUpperBound',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestampUpperBound(transaction)),
            expected: expectedAttachmentTimestampUpperBound
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct attachmentTimestampUpperBound',
            actual: converter_1.tritsToValue(transaction_1.attachmentTimestampUpperBound(transactionBuffer, offset)),
            expected: expectedAttachmentTimestampUpperBound
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('transactionNonce(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(transactionNonce, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionNonce, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct transactionNonce',
            actual: transaction_1.transactionNonce(transaction),
            expected: expectedTransactionNonce
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct transactionNonce',
            actual: transaction_1.transactionNonce(transactionBuffer, offset),
            expected: expectedTransactionNonce
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('transactionEssence(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(transactionEssence, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionEssence, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct transactionEssence',
            actual: transaction_1.transactionEssence(transaction),
            expected: expectedTransactionEssence
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct transactionEssence',
            actual: transaction_1.transactionEssence(transactionBuffer, offset),
            expected: expectedTransactionEssence
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('transactionHash(transactionBuffer, offset)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    var expectedTransactionHash;
    return __generator(this, function (_a) {
        assert({
            given: 'transactionBuffer of length that is not multiple of transaction length',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionHash, new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH)
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'offset = undefined',
        //    should: 'throw TypeError',
        //    actual: Try(transactionHash, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'offset = NaN',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionHash, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = null',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionHash, transaction, null),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = "0" (string)',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionHash, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset = Infinity',
            should: 'throw TypeError',
            actual: riteway_1.Try(transaction_1.transactionHash, transaction, Infinity),
            expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        assert({
            given: 'offset < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.transactionHash, transaction, -transaction_1.TRANSACTION_LENGTH),
            expected: new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET)
        });
        expectedTransactionHash = converter_1.trytesToTrits(samples_1.bundle[0].hash);
        assert({
            given: 'valid transactionBuffer and offset = 0',
            should: 'return correct transaction hash',
            actual: transaction_1.transactionHash(transaction),
            expected: expectedTransactionHash
        });
        assert({
            given: 'valid transactionBuffer and valid offset',
            should: 'return correct transaction hash',
            actual: transaction_1.transactionHash(transactionBuffer, offset),
            expected: expectedTransactionHash
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('isTransaction(transaction, minWeightMagnitude)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddress)) <= 0 ||
            converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddressB)) > 0) {
            throw new Error('Transaction value is assumed to be non-zero.');
        }
        assert({
            given: 'transaction of illegal length',
            should: 'return false',
            actual: transaction_1.isTransaction(new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: false
        });
        assert({
            given: 'positive value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isTransaction(transactionWithInvalidAddress),
            expected: false
        });
        assert({
            given: 'negative value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isTransaction(transactionWithInvalidAddressB),
            expected: false
        });
        // undefined -> 0, because of default argument
        // assert({
        //    given: 'minWeightMagnitude = undefined',
        //    should: 'throw Error',
        //    actual: Try(isTransaction, transaction, undefined as any)),
        //    expected: new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET),
        // })
        assert({
            given: 'minWeightMagnitude = NaN',
            should: 'throw Error',
            actual: riteway_1.Try(transaction_1.isTransaction, transaction, NaN),
            expected: new TypeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE)
        });
        assert({
            given: 'minWeightMagnitude = null',
            should: 'throw Error',
            actual: riteway_1.Try(transaction_1.isTransaction, transaction, null),
            expected: new TypeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE)
        });
        assert({
            given: 'minWeightMagnitude = "0" (string)',
            should: 'throw Error',
            actual: riteway_1.Try(transaction_1.isTransaction, transaction, '0'),
            expected: new TypeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE)
        });
        assert({
            given: 'minWeightMagnitude < 0',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.isTransaction, transaction, -1),
            expected: new RangeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE)
        });
        assert({
            given: 'minWeightMagnitude > TRANSACTION_HASH_LENGTH',
            should: 'throw RangeError',
            actual: riteway_1.Try(transaction_1.isTransaction, transaction, transaction_1.TRANSACTION_HASH_LENGTH + 1),
            expected: new RangeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE)
        });
        assert({
            given: 'valid transaction and higher minWeightMagnitude',
            should: 'return false',
            actual: transaction_1.isTransaction(transaction, minWeightMagnitude + 1),
            expected: false
        });
        assert({
            given: 'valid transaction and exact minWeightMagnitude',
            should: 'return true',
            actual: transaction_1.isTransaction(transaction, minWeightMagnitude),
            expected: true
        });
        assert({
            given: 'valid transaction and lower minWeightMagnitude',
            should: 'return true',
            actual: transaction_1.isTransaction(transaction, minWeightMagnitude - 1),
            expected: true
        });
        assert({
            given: 'valid transaction',
            should: 'return true',
            actual: transaction_1.isTransaction(transaction),
            expected: true
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('isTail(transaction)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddress)) <= 0 ||
            converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddressB)) > 0) {
            throw new Error('Transaction value is assumed to be non-zero.');
        }
        assert({
            given: 'transaction of illegal length',
            should: 'return false',
            actual: transaction_1.isTail(new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: false
        });
        assert({
            given: 'positive value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isTail(transactionWithInvalidAddress),
            expected: false
        });
        assert({
            given: 'negative value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isTail(transactionWithInvalidAddressB),
            expected: false
        });
        assert({
            given: 'valid non-tail transaction (currentIndex > 0)',
            should: 'return false',
            actual: transaction_1.isTail(converter_1.trytesToTrits(samples_1.bundleTrytes[1])),
            expected: false
        });
        assert({
            given: 'valid tail transaction (currentIndex = 0)',
            should: 'return true',
            actual: transaction_1.isTail(converter_1.trytesToTrits(samples_1.bundleTrytes[0])),
            expected: true
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('isHead(transaction)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddress)) <= 0 ||
            converter_1.tritsToValue(transaction_1.value(transactionWithInvalidAddressB)) > 0) {
            throw new Error('Transaction value is assumed to be non-zero.');
        }
        assert({
            given: 'transaction of illegal length',
            should: 'return false',
            actual: transaction_1.isHead(new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: false
        });
        assert({
            given: 'positive value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isHead(transactionWithInvalidAddress),
            expected: false
        });
        assert({
            given: 'negative value transaction with last trit of address != 0',
            should: 'return false',
            actual: transaction_1.isHead(transactionWithInvalidAddressB),
            expected: false
        });
        assert({
            given: 'valid non-tail transaction (currentIndex > 0)',
            should: 'return false',
            actual: transaction_1.isHead(converter_1.trytesToTrits(samples_1.bundleTrytes[0])),
            expected: false
        });
        assert({
            given: 'valid tail transaction (currentIndex = 0)',
            should: 'return true',
            actual: transaction_1.isHead(converter_1.trytesToTrits(samples_1.bundleTrytes[samples_1.bundleTrytes.length - 1])),
            expected: true
        });
        return [2 /*return*/];
    });
}); });
riteway_1.describe('isAttached(transaction)', function (assert) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        assert({
            given: 'transaction of illegal length',
            should: 'return false',
            actual: transaction_1.isAttached(new Int8Array(transaction_1.TRANSACTION_LENGTH - 1)),
            expected: false
        });
        assert({
            given: 'non-attached transaction',
            should: 'return false',
            actual: transaction_1.isAttached(new Int8Array(transaction_1.TRANSACTION_LENGTH)),
            expected: false
        });
        assert({
            given: 'attached transaction',
            should: 'return true',
            actual: transaction_1.isAttached(new Int8Array(transaction_1.TRANSACTION_LENGTH).fill(1, transaction_1.ATTACHMENT_TIMESTAMP_OFFSET, transaction_1.ATTACHMENT_TIMESTAMP_OFFSET + 1)),
            expected: true
        });
        return [2 /*return*/];
    });
}); });
//# sourceMappingURL=transaction.test.js.map