"use strict";
exports.__esModule = true;
/**
 * @module transaction
 */
var converter_1 = require("@iota/converter");
var curl_1 = require("@iota/curl");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var warning = require("warning");
var errors = require("../../errors");
var guards_1 = require("../../guards");
require("../../typed-array");
exports.SIGNATURE_OR_MESSAGE_OFFSET = 0;
exports.SIGNATURE_OR_MESSAGE_LENGTH = signing_1.FRAGMENT_LENGTH;
// export const EXTRA_DATA_DIGEST_OFFSET = SIGNATURE_OR_MESSAGE_OFFSET + SIGNATURE_OR_MESSAGE_LENGTH
// export const EXTRA_DATA_DIGEST_LENGTH = 243
exports.ADDRESS_OFFSET = exports.SIGNATURE_OR_MESSAGE_OFFSET + exports.SIGNATURE_OR_MESSAGE_LENGTH; // EXTRA_DATA_DIGEST_OFFSET + EXTRA_DATA_DIGEST_LENGTH
exports.ADDRESS_LENGTH = kerl_1["default"].HASH_LENGTH;
exports.VALUE_OFFSET = exports.ADDRESS_OFFSET + exports.ADDRESS_LENGTH;
exports.VALUE_LENGTH = 81;
exports.OBSOLETE_TAG_OFFSET = exports.VALUE_OFFSET + exports.VALUE_LENGTH;
exports.OBSOLETE_TAG_LENGTH = 81;
exports.ISSUANCE_TIMESTAMP_OFFSET = exports.OBSOLETE_TAG_OFFSET + exports.OBSOLETE_TAG_LENGTH;
exports.ISSUANCE_TIMESTAMP_LENGTH = 27;
// export const TIMELOCK_LOWER_BOUND_OFFSET = ISSUANCE_TIMESTAMP_OFFSET + ISSUANCE_TIMESTAMP_LENGTH
// export const TIMELOCK_LOWER_BOUND_LENGTH = 27
// export const TIMELOCK_UPPER_BOUND_OFFSET = TIMELOCK_LOWER_BOUND_OFFSET + TIMELOCK_LOWER_BOUND_LENGTH
// export const TIMELOCK_UPPER_BOUND_LENGTH = 27
exports.CURRENT_INDEX_OFFSET = exports.ISSUANCE_TIMESTAMP_OFFSET + exports.ISSUANCE_TIMESTAMP_LENGTH;
exports.CURRENT_INDEX_LENGTH = 27;
exports.LAST_INDEX_OFFSET = exports.CURRENT_INDEX_OFFSET + exports.CURRENT_INDEX_LENGTH;
exports.LAST_INDEX_LENGTH = 27;
// export const BUNDLE_NONCE_OFFSET = TIMELOCK_UPPER_BOUND_OFFSET + TIMELOCK_LOWER_BOUND_LENGTH
// export const BUNDLE_NONCE_LENGTH = 243
exports.BUNDLE_OFFSET = exports.LAST_INDEX_OFFSET + exports.LAST_INDEX_LENGTH;
exports.BUNDLE_LENGTH = kerl_1["default"].HASH_LENGTH;
exports.TRUNK_TRANSACTION_OFFSET = exports.BUNDLE_OFFSET + exports.BUNDLE_LENGTH; // BUNDLE_NONCE_OFFSET + BUNDLE_NONCE_LENGTH
exports.TRUNK_TRANSACTION_LENGTH = curl_1["default"].HASH_LENGTH;
exports.BRANCH_TRANSACTION_OFFSET = exports.TRUNK_TRANSACTION_OFFSET + exports.TRUNK_TRANSACTION_LENGTH;
exports.BRANCH_TRANSACTION_LENGTH = curl_1["default"].HASH_LENGTH;
exports.TAG_OFFSET = exports.BRANCH_TRANSACTION_OFFSET + exports.BRANCH_TRANSACTION_LENGTH;
exports.TAG_LENGTH = 81;
exports.ATTACHMENT_TIMESTAMP_OFFSET = exports.TAG_OFFSET + exports.TAG_LENGTH;
exports.ATTACHMENT_TIMESTAMP_LENGTH = 27;
exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_OFFSET = exports.ATTACHMENT_TIMESTAMP_OFFSET + exports.ATTACHMENT_TIMESTAMP_LENGTH;
exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_LENGTH = 27;
exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_OFFSET = exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_OFFSET + exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_LENGTH;
exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_LENGTH = 27;
exports.TRANSACTION_NONCE_OFFSET = exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_OFFSET + exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_LENGTH;
exports.TRANSACTION_NONCE_LENGTH = 81;
exports.TRANSACTION_ESSENCE_OFFSET = exports.ADDRESS_OFFSET; // EXTRA_DATA_DIGEST_OFFSET
exports.TRANSACTION_ESSENCE_LENGTH = exports.BUNDLE_OFFSET - exports.ADDRESS_OFFSET; // BUNDLE_NONCE_OFFSET - EXTRA_DATA_DIGEST_OFFSET
exports.TRANSACTION_LENGTH = exports.TRANSACTION_NONCE_OFFSET + exports.TRANSACTION_NONCE_LENGTH;
exports.TRANSACTION_HASH_LENGTH = curl_1["default"].HASH_LENGTH;
/**
 * Checks if given value is a valid transaction buffer length or offset.
 *
 * @method isMultipleOfTransactionLength
 *
 * @param {Int8Array} lengthOrOffset
 *
 * @return {boolean}
 */
exports.isMultipleOfTransactionLength = function (lengthOrOffset) {
    if (!Number.isInteger(lengthOrOffset)) {
        throw new TypeError(errors.ILLEGAL_LENGTH_OR_OFFSET);
    }
    return lengthOrOffset >= 0 && lengthOrOffset % exports.TRANSACTION_LENGTH === 0;
};
/**
 * Creates a function that copies a fixed size part of the buffer.
 *
 * @method transactionBufferSlice
 *
 * @param {number} transactionFieldOffset
 * @param {number} transactionFieldLength
 *
 * @return {Function}
 *
 * @ignore
 */
exports.transactionBufferSlice = function (transactionFieldOffset, transactionFieldLength) {
    if (!Number.isInteger(transactionFieldOffset)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET);
    }
    if (transactionFieldOffset < 0) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_FIELD_OFFSET);
    }
    if (!Number.isInteger(transactionFieldLength)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH);
    }
    if (transactionFieldLength < 0) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_FIELD_LENGTH);
    }
    return function (transactionBuffer, transactionOffset) {
        if (transactionOffset === void 0) { transactionOffset = 0; }
        if (!(transactionBuffer instanceof Int8Array)) {
            throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER);
        }
        if (!exports.isMultipleOfTransactionLength(transactionBuffer.length)) {
            throw new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
        }
        if (!exports.isMultipleOfTransactionLength(transactionOffset)) {
            throw new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET);
        }
        return transactionBuffer.slice(transactionOffset + transactionFieldOffset, transactionOffset + transactionFieldOffset + transactionFieldLength);
    };
};
/**
 * Gets the `signatureOrMessage` field of all transactions in a bundle.
 *
 * @method signatureOrMessage
 *
 * @param {Int8Array} buffer - Transaction trytes
 *
 * @return {Int8Array}
 */
exports.signatureOrMessage = exports.transactionBufferSlice(exports.SIGNATURE_OR_MESSAGE_OFFSET, exports.SIGNATURE_OR_MESSAGE_LENGTH);
/**
 * Returns a copy of `address` field.
 *
 * @method address
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.address = exports.transactionBufferSlice(exports.ADDRESS_OFFSET, exports.ADDRESS_LENGTH);
/**
 * Returns a copy of `value` field.
 *
 * @method value
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.value = exports.transactionBufferSlice(exports.VALUE_OFFSET, exports.VALUE_LENGTH);
exports.createObsoleteTag = function (warn) {
    if (warn === void 0) { warn = true; }
    /**
     * Returns a copy of `obsoleteTag` field.
     *
     * @method obsoleteTag
     *
     * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
     * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
     *
     * @return {Int8Array}
     */
    return function (buffer, offset) {
        if (offset === void 0) { offset = 0; }
        warning(warn, 'Deprecation warning: `obsoleteTag` field will be removed in final design.');
        return exports.transactionBufferSlice(exports.OBSOLETE_TAG_OFFSET, exports.OBSOLETE_TAG_LENGTH)(buffer, offset);
    };
};
exports.obsoleteTag = exports.createObsoleteTag();
/**
 * Returns a copy of `issuanceTimestamp` field.
 *
 * @method issuanceTimestamp
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.issuanceTimestamp = exports.transactionBufferSlice(exports.ISSUANCE_TIMESTAMP_OFFSET, exports.ISSUANCE_TIMESTAMP_LENGTH);
exports.createCurrentIndex = function (warn) {
    if (warn === void 0) { warn = true; }
    /**
     * Returns a copy of `currentIndex` field.
     *
     * @method currentIndex
     *
     * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
     * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
     *
     * @return {Int8Array}
     */
    return function (buffer, offset) {
        if (offset === void 0) { offset = 0; }
        warning(warn, 'Deprecation warning: `currentIndex` field will be removed in final design.');
        return exports.transactionBufferSlice(exports.CURRENT_INDEX_OFFSET, exports.CURRENT_INDEX_LENGTH)(buffer, offset);
    };
};
exports.currentIndex = exports.createCurrentIndex();
exports.createLastIndex = function (warn) {
    if (warn === void 0) { warn = true; }
    /**
     * Returns a copy of `lastIndex` field.
     *
     * @method lastIndex
     *
     * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
     * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
     *
     * @return {Int8Array}
     */
    return function (buffer, offset) {
        if (offset === void 0) { offset = 0; }
        warning(warn, 'Deprecation warning: `lastIndex` field will be removed in final design.');
        return exports.transactionBufferSlice(exports.LAST_INDEX_OFFSET, exports.LAST_INDEX_LENGTH)(buffer, offset);
    };
};
exports.lastIndex = exports.createLastIndex();
exports.createBundle = function (warn) {
    if (warn === void 0) { warn = true; }
    /**
     * Returns a copy of `bundle` field.
     *
     * @method bundle
     *
     * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
     * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
     *
     * @return {Int8Array}
     */
    return function (buffer, offset) {
        if (offset === void 0) { offset = 0; }
        warning(warn, 'Deprecation warning: `bundle` field will be removed in final design.');
        return exports.transactionBufferSlice(exports.BUNDLE_OFFSET, exports.BUNDLE_LENGTH)(buffer, offset);
    };
};
exports.bundle = exports.createBundle();
/**
 * Returns a copy of `trunkTransaction` field.
 *
 * @method trunkTransaction
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.trunkTransaction = exports.transactionBufferSlice(exports.TRUNK_TRANSACTION_OFFSET, exports.TRUNK_TRANSACTION_LENGTH);
/**
 * Returns a copy of `branchTransaction` field.
 *
 * @method branchTransaction
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.branchTransaction = exports.transactionBufferSlice(exports.BRANCH_TRANSACTION_OFFSET, exports.BRANCH_TRANSACTION_LENGTH);
/**
 * Returns a copy of `tag` field.
 *
 * @method tag
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.tag = exports.transactionBufferSlice(exports.TAG_OFFSET, exports.TAG_LENGTH);
/**
 * Returns a copy of `attachmentTimestamp` field.
 *
 * @method attachmentTimestamp
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.attachmentTimestamp = exports.transactionBufferSlice(exports.ATTACHMENT_TIMESTAMP_OFFSET, exports.ATTACHMENT_TIMESTAMP_LENGTH);
/**
 * Returns a copy of `attachmentTimestampLowerBound` field.
 *
 * @method attachmentTimestampLowerBound
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.attachmentTimestampLowerBound = exports.transactionBufferSlice(exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_OFFSET, exports.ATTACHMENT_TIMESTAMP_LOWER_BOUND_LENGTH);
/**
 * Returns a copy of `attachmentTimestampUpperBound` field.
 *
 * @method attachmentTimestampUpperBound
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.attachmentTimestampUpperBound = exports.transactionBufferSlice(exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_OFFSET, exports.ATTACHMENT_TIMESTAMP_UPPER_BOUND_LENGTH);
/**
 * Returns a copy of `tansactionNonce` field.
 *
 * @method transactionNonce
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.transactionNonce = exports.transactionBufferSlice(exports.TRANSACTION_NONCE_OFFSET, exports.TRANSACTION_NONCE_LENGTH);
/**
 * Returns a copy of transaction essence fields.
 *
 * @method bundle
 *
 * @param {Int8Array} buffer - Transaction buffer. Buffer length must be a multiple of transaction length.
 * @param {Number} [offset=0] - Transaction trit offset. It must be a multiple of transaction length.
 *
 * @return {Int8Array}
 */
exports.transactionEssence = exports.transactionBufferSlice(exports.TRANSACTION_ESSENCE_OFFSET, exports.TRANSACTION_ESSENCE_LENGTH);
/**
 * This method takes transaction trits, and returns the transaction hash.
 *
 * ## Related methods
 *
 * To validate the length of transaction trits, use the [`isMultipleOfTransactionLength()`]{@link #module_transaction.isMultipleOfTransactionLength} method.
 *
 * To get a transaction's trits from the Tangle, use the [`getTrytes()`]{@link #module_core.getTrytes} method, then convert them to trits, using the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method transactionHash
 *
 * @summary Generates the transaction hash for a given transaction.
 *
 * @memberof module:transaction
 *
 * @param {Int8Array} buffer - Transactions in trits
 * @param {Number} [offset=0] - Offset in trits to define a transaction to hash in the `buffer` argument
 *
 * @example
 * ```js
 * let hash = Transaction.transactionHash(transactions);
 * ```
 *
 * @return {Int8Array} Transaction hash
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `buffer` argument contains 8,019 trits (the length of a transaction without the transaction hash).
 * @throws {errors.ILLEGAL_TRANSACTION_OFFSET}: Make sure that the `offset` argument is a multiple of 8,019 (the length of a transaction without the transaction hash).
 */
exports.transactionHash = function (buffer, offset) {
    if (offset === void 0) { offset = 0; }
    if (!exports.isMultipleOfTransactionLength(buffer.length)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (!exports.isMultipleOfTransactionLength(offset)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_OFFSET);
    }
    var output = new Int8Array(curl_1["default"].HASH_LENGTH);
    var sponge = new curl_1["default"]();
    sponge.absorb(buffer, offset, exports.TRANSACTION_LENGTH);
    sponge.squeeze(output, 0, curl_1["default"].HASH_LENGTH);
    return output;
};
/* Guards */
/**
 * This method takes an array of transaction trits and validates whether they form a valid transaction by checking the following:
 *
 * - Addresses in value transactions have a 0 trit at the end, which means they were generated using the Kerl hashing function
 * - The transaction would result in a valid hash, according to the given [`minWeightMagnitude`](https://docs.iota.org/docs/getting-started/0.1/network/minimum-weight-magnitude) argument
 *
 * ## Related methods
 *
 * To get a transaction's trits from the Tangle, use the [`getTrytes()`]{@link #module_core.getTrytes} method, then convert them to trits, using the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method isTransaction
 *
 * @summary Validates the structure and contents of a given transaction.
 *
 * @memberof module:transaction
 *
 * @param {Int8Array} transaction - Transaction trits
 * @param {number} [minWeightMagnitude=0] - Minimum weight magnitude
 *
 * @example
 * ```js
 * let valid = Transaction.isTransaction(transaction);
 * ```
 *
 * @return {boolean} valid - Whether the transaction is valid.
 *
 * @throws {errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE}: Make sure that the `minWeightMagnitude` argument is a number between 1 and 81.
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `transaction` argument contains 8,019 trits (the length of a transaction without the transaction hash).
 */
exports.isTransaction = function (transaction, minWeightMagnitude) {
    if (minWeightMagnitude === void 0) { minWeightMagnitude = 0; }
    if (!Number.isInteger(minWeightMagnitude)) {
        throw new TypeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE);
    }
    if (minWeightMagnitude < 0 || minWeightMagnitude > exports.TRANSACTION_HASH_LENGTH) {
        throw new RangeError(errors.ILLEGAL_MIN_WEIGHT_MAGNITUDE);
    }
    return (transaction.length === exports.TRANSACTION_LENGTH &&
        guards_1.isTrits(transaction) &&
        // Last address trit of value transaction must be 0.
        // Revisions in signature scheme may affect this in the future.
        (converter_1.tritsToValue(exports.value(transaction)) === 0 || transaction[exports.ADDRESS_OFFSET + exports.ADDRESS_LENGTH - 1] === 0) &&
        (!minWeightMagnitude ||
            exports.transactionHash(transaction)
                .subarray(exports.TRANSACTION_HASH_LENGTH - minWeightMagnitude, exports.TRANSACTION_HASH_LENGTH)
                .every(function (trit) { return trit === 0; })));
};
/**
 * This method takes an array of transaction trits, and checks its `currentIndex` field to validate whether it is the tail transaction in a bundle.
 *
 * ## Related methods
 *
 * To get a transaction's trits from the Tangle, use the [`getTrytes()`]{@link #module_core.getTrytes} method, then convert them to trits, using the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method isTailTransaction
 *
 * @summary Checks if the given transaction is a tail transaction in a bundle.
 *
 * @memberof module:transaction
 *
 * @param {Int8Array} transaction - Transaction trits
 *
 * @example
 * ```js
 * let tail = Transaction.isTailTransaction(transaction);
 * ```
 *
 * @return {boolean} tail - Whether the transaction is a tail transaction.
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `transaction` argument contains 8,019 trits (the length of a transaction without the transaction hash).
 */
exports.isTail = function (transaction) {
    return exports.isTransaction(transaction) && converter_1.tritsToValue(exports.createCurrentIndex(false)(transaction)) === 0;
};
/**
 * This method takes an array of transaction trits, and checks its `currentIndex` field to validate whether it is the head transaction in a bundle.
 *
 * ## Related methods
 *
 * To get a transaction's trits from the Tangle, use the [`getTrytes()`]{@link #module_core.getTrytes} method, then convert them to trits, using the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method isHeadTransaction
 *
 * @summary Checks if the given transaction is a head transaction in a bundle.
 *
 * @memberof module:transaction
 *
 * @param {Int8Array} transaction - Transaction trits
 *
 * @example
 * ```js
 * let head = Transaction.isHeadTransaction(transaction);
 * ```
 *
 * @return {boolean} head - Whether the transaction is a head transaction.
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `transaction` argument contains 8,019 trits (the length of a transaction without the transaction hash).
 */
exports.isHead = function (transaction) {
    return exports.isTransaction(transaction) &&
        converter_1.tritsToValue(exports.createCurrentIndex(false)(transaction)) === converter_1.tritsToValue(exports.createLastIndex(false)(transaction));
};
/**
 * This method checks if the given transaction trits include a proof of work by validating that the its `attachmentTimestamp` field has a non-zero value.
 *
 * The `attachmentTimestamp` field is set by the `attachToTangle` endpoint. Therefore, if this field is non-zero, this method assumes that proof of work was done.
 *
 * **Note:** This method does not validate proof of work.
 *
 * ## Related methods
 *
 * To get a transaction's trits from the Tangle, use the [`getTrytes()`]{@link #module_core.getTrytes} method, then convert them to trits, using the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method isAttachedTransaction
 *
 * @ignore
 *
 * @summary Checks if the given transaction has a non-zero value in its `attachmentTimestamp` field.
 *
 * @memberof module:transaction
 *
 * @param {Int8Array} transaction - Transaction trits
 *
 * @example
 * ```js
 * let attached = Transaction.isAttachedTransaction(transaction);
 * ```
 *
 * @return {boolean} attached - Whether the transaction has a non-zero value in its `attachmentTimestamp` field.
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `transaction` argument contains 8,019 trits (the length of a transaction without the transaction hash).
 */
exports.isAttached = function (transaction) {
    return exports.isTransaction(transaction) &&
        transaction
            .subarray(exports.ATTACHMENT_TIMESTAMP_OFFSET, exports.ATTACHMENT_TIMESTAMP_OFFSET + exports.ATTACHMENT_TIMESTAMP_LENGTH)
            .some(function (trit) { return trit !== 0; });
};
//# sourceMappingURL=transaction.js.map