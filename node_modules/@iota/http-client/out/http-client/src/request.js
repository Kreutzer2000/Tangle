"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
require("cross-fetch/polyfill"); // tslint:disable-line no-submodule-imports
var parseUrl = require("url-parse");
var types_1 = require("../../types");
var settings_1 = require("./settings");
var requestError = function (statusText) { return "Request error: " + statusText; };
/**
 * Sends an http request to a specified host.
 *
 * @method send
 *
 * @memberof module:http-client
 *
 * @param {Command} command
 *
 * @param {String} [uri=http://localhost:14265]
 *
 * @param {String|Number} [apiVersion=1]
 *
 * @return Promise
 * @fulil {Object} - Response
 * @reject {Error} - Request error
 */
exports.send = function (params) {
    var headers = {
        'Content-Type': 'application/json',
        'X-IOTA-API-Version': (params.apiVersion || settings_1.API_VERSION).toString()
    };
    var uri = params.uri || settings_1.DEFAULT_URI;
    if (params.user && params.password) {
        if (parseUrl(uri, true).protocol !== 'https:') {
            throw new Error('Basic auth requires https.');
        }
        headers.Authorization = "Basic " + Buffer.from(params.user + ":" + params.password).toString('base64');
    }
    return fetch(uri, {
        method: 'POST',
        headers: headers,
        body: JSON.stringify(params.command),
        agent: params.agent
    }).then(function (res) {
        return res
            .json()
            .then(function (json) {
            return res.ok
                ? json
                : Promise.reject(new Error(requestError(json.error || json.exception ? json.error || json.exception : res.statusText)));
        })["catch"](function (error) {
            if (!res.ok && error.type === 'invalid-json') {
                throw new Error(requestError(res.statusText));
            }
            else {
                throw error;
            }
        });
    });
};
/**
 * Sends a batched http request to a specified host
 * supports findTransactions, getBalances & getTrytes commands
 *
 * @method batchedSend
 *
 * @param {Command} command
 *
 * @param {String[]} keysToBatch
 *
 * @param {Number} [requestBatchSize=1000]
 *
 * @param {String} [uri='http://localhost:14265']
 *
 * @param {String|Number} [apiVersion=1]
 *
 * @ignore
 *
 * @return Promise
 * @fulil {Object} - Response
 * @reject {Error} - Request error
 */
exports.batchedSend = function (requestParams, keysToBatch, requestBatchSize) {
    if (requestBatchSize === void 0) { requestBatchSize = settings_1.REQUEST_BATCH_SIZE; }
    var params = Object.keys(requestParams.command)
        .filter(function (key) { return keysToBatch.indexOf(key) === -1; })
        .reduce(function (acc, key) {
        var _a;
        return (__assign({}, acc, (_a = {}, _a[key] = requestParams.command[key], _a)));
    }, {});
    return Promise.all(keysToBatch.map(function (key) {
        return Promise.all(requestParams.command[key]
            .reduce(function (acc, _, // tslint:disable-line no-unused-variable
        i) {
            var _a;
            return i < Math.ceil(requestParams.command[key].length / requestBatchSize)
                ? acc.concat(__assign({}, params, (_a = {}, _a[key] = requestParams.command[key].slice(i * requestBatchSize, (1 + i) * requestBatchSize), _a)))
                : acc;
        }, [])
            .map(function (batchedCommand) { return exports.send(__assign({}, requestParams, { command: batchedCommand })); })).then(function (res) { return res.reduce(function (acc, batch) { return acc.concat(batch); }, []); });
    })).then(function (responses) {
        switch (requestParams.command.command) {
            case types_1.IRICommand.FIND_TRANSACTIONS:
                return {
                    hashes: responses[0][0].hashes.filter(function (hash) {
                        return responses.every(function (response) {
                            return response.findIndex(function (res) { return res.hashes.indexOf(hash) > -1; }) > -1;
                        });
                    })
                };
            case types_1.IRICommand.GET_BALANCES:
                return __assign({}, responses[0]
                    .slice()
                    .sort(function (a, b) { return a.milestoneIndex - b.milestoneIndex; })
                    .slice(-1)[0], { balances: responses[0].reduce(function (acc, response) {
                        return acc.concat(response.balances);
                    }, []) });
            case types_1.IRICommand.GET_INCLUSION_STATES:
                return __assign({}, responses[0][0], { states: responses[0].reduce(function (acc, response) {
                        return acc.concat(response.states);
                    }, []) });
            case types_1.IRICommand.GET_TRYTES:
                return {
                    trytes: responses[0].reduce(function (acc, response) { return acc.concat(response.trytes); }, [])
                };
            default:
                throw requestError('Invalid batched request.');
        }
    });
};
//# sourceMappingURL=request.js.map