"use strict";
/** @module bundle */
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var kerl_1 = require("@iota/kerl");
var signing_1 = require("@iota/signing");
var errors = require("../../errors");
require("../../typed-array");
var transaction_1 = require("@iota/transaction");
/**
 * @method createBundle
 *
 * @summary Creates a bundle array from the given transaction entries.
 *
 * @param {BundleEntry[]} [entries=[]] - Entries of single or multiple transactions with the same address
 *
 * @return {Int8Array[]} List of transactions in the bundle
 */
exports.createBundle = function (entries) {
    if (entries === void 0) { entries = []; }
    return entries.reduce(function (bundle, entry) { return exports.addEntry(bundle, entry); }, new Int8Array(0));
};
/**
 * Adds transaction trits in the given entry object to a given bundle array.
 *
 * ## Related methods
 *
 * See the [converter](https://github.com/iotaledger/iota.js/tree/next/packages/converter) package for methods that convert values to trits.
 *
 * @method addEntry
 *
 * @summary Adds the given transaction entry to a bundle array.
 *
 * @memberof module:bundle
 *
 * @param {object} entry - Transaction entry object
 * @param {Int8Array} entry.address - An address in trits
 * @param {Int8Array} entry.value - An amount of IOTA tokens in trits
 * @param {Int8Array} [entry.signatureOrMessage] - Signature fragments or a message in trits
 * @param {Int8Array} [entry.issuanceTimestamp] - Unix epoch in trits
 * @param {Int8Array} [entry.tag] - (deprecated)
 * @param {Int8Array} bundle - Bundle array to which to add the entry object
 *
 * @example
 * ```js
 * let bundle = new Int8Array();
 *
 * bundle = Bundle.addEntry(bundle, {
 *  address: Converter.trytesToTrits(outputAddress),
 *  value: Converter.valueToTrits(value),
 *  issuanceTimestamp: Converter.valueToTrits(Math.floor(Date.now() / 1000));
 * });
 * ```
 *
 * @return {Int8Array} A copy of the original bundle that also includes the added entries.
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `bundle` argument contains valid transaction trits
 * @throws {errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH}: Make sure that the `entry.signatureOrMessage` argument contains 6,561 trits
 * @throws {errors.ILLEGAL_ADDRESS_LENGTH}: Make sure that the `entry.address` argument contains 243 trits
 * @throws {errors.ILLEGAL_VALUE_LENGTH}: Make sure that the `entry.value` argument contains 6,561 trits
 * @throws {errors.ILLEGAL_ISSUANCE_TIMESTAMP_LENGTH}: Make sure that the `entry.timestamp` argument contains 81 trits
 */
exports.addEntry = function (bundle, entry) {
    var signatureOrMessage = entry.signatureOrMessage, 
    // extraDataDigest,
    address = entry.address, value = entry.value, obsoleteTag = entry.obsoleteTag, issuanceTimestamp = entry.issuanceTimestamp, tag = entry.tag;
    /*
    warning(
        signatureOrMessage && !isNullTrits(signatureOrMessage),
        'Deprecation warning: \n' +
            ' - Use of "signatureOrMessage" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )

    warning(
        obsoleteTag && !isNullTrits(obsoleteTag),
        'Deprecation warning: \n' +
            ' - "obseleteTag" field is deprecated and will be removed in implementation of final design. \n' +
            ' - Use of "obsoleteTag" or "tag" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )

    warning(
        tag && !isNullTrits(tag),
        'Deprecation warning: \n' +
            ' - Use of "tag" field before bundle finalization is deprecated and will be removed in v1.0.0. \n'
    )
    */
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (signatureOrMessage &&
        (signatureOrMessage.length === 0 || signatureOrMessage.length % transaction_1.SIGNATURE_OR_MESSAGE_LENGTH !== 0)) {
        throw new RangeError(errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH);
    }
    if (address && address.length !== transaction_1.ADDRESS_LENGTH) {
        throw new RangeError(errors.ILLEGAL_ADDRESS_LENGTH);
    }
    if (value && value.length > transaction_1.VALUE_LENGTH) {
        throw new RangeError(errors.ILLEGAL_VALUE_LENGTH);
    }
    if (obsoleteTag && obsoleteTag.length > transaction_1.OBSOLETE_TAG_LENGTH) {
        throw new RangeError(errors.ILLEGAL_OBSOLETE_TAG_LENGTH);
    }
    if (issuanceTimestamp && issuanceTimestamp.length > transaction_1.ISSUANCE_TIMESTAMP_LENGTH) {
        throw new RangeError(errors.ILLEGAL_ISSUANCE_TIMESTAMP_LENGTH);
    }
    if (tag && tag.length > transaction_1.TAG_LENGTH) {
        throw new RangeError(errors.ILLEGAL_TAG_LENGTH);
    }
    var signatureOrMessageCopy = signatureOrMessage
        ? signatureOrMessage.slice()
        : new Int8Array(transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
    var numberOfFragments = signatureOrMessageCopy.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
    var bundleCopy = new Int8Array(bundle.length + numberOfFragments * transaction_1.TRANSACTION_LENGTH);
    var currentIndexBuffer = bundle.length > 0 ? signing_1.increment(transaction_1.lastIndex(bundle)) : new Int8Array(transaction_1.LAST_INDEX_LENGTH);
    var lastIndexBuffer = currentIndexBuffer.slice();
    var fragmentIndex = 0;
    bundleCopy.set(bundle.slice());
    // Create and append transactions to the bundle.
    for (var offset = bundle.length; offset < bundleCopy.length; offset += transaction_1.TRANSACTION_LENGTH) {
        var signatureOrMessageCopyFragment = signatureOrMessageCopy.subarray(fragmentIndex * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH, (fragmentIndex + 1) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
        bundleCopy.set(signatureOrMessageCopyFragment, offset + transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
        if (address) {
            bundleCopy.set(address, offset + transaction_1.ADDRESS_OFFSET);
        }
        if (value && fragmentIndex === 0) {
            bundleCopy.set(value, offset + transaction_1.VALUE_OFFSET);
        }
        if (obsoleteTag) {
            bundleCopy.set(obsoleteTag, offset + transaction_1.OBSOLETE_TAG_OFFSET);
        }
        if (issuanceTimestamp) {
            bundleCopy.set(issuanceTimestamp, offset + transaction_1.ISSUANCE_TIMESTAMP_OFFSET);
        }
        bundleCopy.set(currentIndexBuffer, offset + transaction_1.CURRENT_INDEX_OFFSET);
        if (tag) {
            bundleCopy.set(tag, offset + transaction_1.TAG_OFFSET);
        }
        lastIndexBuffer.set(currentIndexBuffer.slice());
        currentIndexBuffer.set(signing_1.increment(currentIndexBuffer));
        fragmentIndex++;
    }
    for (var offset = transaction_1.LAST_INDEX_OFFSET; offset < bundleCopy.length; offset += transaction_1.TRANSACTION_LENGTH) {
        bundleCopy.set(lastIndexBuffer, offset);
    }
    return bundleCopy;
};
/**
 * This method takes an array of transaction trits, generates the bundle hash, and adds it to each transaction.
 *
 * ## Related methods
 *
 * See the [`addEntry()`]{@link #module_bundle.addEntry} method for creating new bundles.
 *
 * @method finalizeBundle
 *
 * @summary Generates a bundle hash.
 *
 * @memberof module:bundle
 *
 * @param {Int8Array} bundle - Transaction trits
 *
 * @example
 * ```js
 * const result = Bundle.finalizeBundle(bundle);
 * ```
 *
 * @return {Int8Array} Transaction trits that include a bundle hash
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `bundle` argument contains valid transaction trits
 */
exports.finalizeBundle = function (bundle, numberOfFragments) {
    if (numberOfFragments === void 0) { numberOfFragments = 3; }
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    var sponge = new kerl_1["default"]();
    var bundleCopy = bundle.slice();
    var bundleHash = new Int8Array(transaction_1.BUNDLE_LENGTH);
    // This block recomputes bundle hash by incrementing `obsoleteTag` field of first transaction in the bundle.
    // Normalized bundle should NOT contain value `13`.
    while (true) {
        // Absorb essence trits to squeeze bundle hash.
        for (var offset = 0; offset < bundle.length; offset += transaction_1.TRANSACTION_LENGTH) {
            sponge.absorb(transaction_1.transactionEssence(bundleCopy, offset), 0, transaction_1.TRANSACTION_ESSENCE_LENGTH);
        }
        // Set new bundle hash value.
        sponge.squeeze(bundleHash, 0, transaction_1.BUNDLE_LENGTH);
        // Stop mutation if essence results to secure bundle.
        if (signing_1.normalizedBundle(bundleHash).slice(0, numberOfFragments * signing_1.NORMALIZED_FRAGMENT_LENGTH).indexOf(signing_1.MAX_TRYTE_VALUE /* 13 */) === -1) {
            // Essence results to secure bundle.
            break;
        }
        // Essence results to insecure bundle. (Normalized bundle hash contains value `13`.)
        bundleCopy.set(signing_1.increment(bundleCopy.subarray(transaction_1.OBSOLETE_TAG_OFFSET, transaction_1.OBSOLETE_TAG_OFFSET + transaction_1.OBSOLETE_TAG_LENGTH)), transaction_1.OBSOLETE_TAG_OFFSET);
        sponge.reset();
    }
    // Set bundle field of each transaction.
    for (var offset = transaction_1.BUNDLE_OFFSET; offset < bundle.length; offset += transaction_1.TRANSACTION_LENGTH) {
        bundleCopy.set(bundleHash, offset);
    }
    return bundleCopy;
};
/**
 * This method takes an array of transaction trits, and add the given message or signature to the transactions, starting from the given index.
 *
 * If the signature or message is too long to fit in a single transaction, it is split across the next transaction in the bundle, starting from the given index.
 *
 * ## Related methods
 *
 * See the [`addEntry()`]{@link #module_bundle.addEntry} method for creating new bundles.
 *
 * @method addSignatureOrMessage
 *
 * @summary Adds signature message fragments to transactions in a bundle.
 *
 * @memberof module:bundle
 *
 * @param {Int8Array} bundle - Transaction trits
 * @param {Int8Array} signatureOrMessage - Signature or message to add to the bundle
 * @param {number} index - Transaction index at which to start adding the signature or message
 *
 * @example
 * ```js
 * const signature = Converter.trytesToTrits('SIGNATURE...')
 * bundle.set(Bundle.addSignatureOrMessage(bundle, signature, 1));
 * ```
 *
 * @return {Int8Array} Transaction trits that include a bundle hash.
 *
 * @throws {errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH}: Make sure that the `bundle` argument contains valid transaction trits
 * @throws {errors.ILLEGAL_TRANSACTION_INDEX}: Make sure that the `index` argument is a number and that the bundle contains enough transactions
 * @throws {errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH}: Make sure that the `signatureOrMessage` argument contains at least 6,561 trits
 *
 */
exports.addSignatureOrMessage = function (bundle, signatureOrMessage, index) {
    if (!transaction_1.isMultipleOfTransactionLength(bundle.length)) {
        throw new Error(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (!Number.isInteger(index)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_INDEX);
    }
    if (signatureOrMessage.length === 0 || signatureOrMessage.length % transaction_1.SIGNATURE_OR_MESSAGE_LENGTH !== 0) {
        throw new RangeError(errors.ILLEGAL_SIGNATURE_OR_MESSAGE_LENGTH);
    }
    if (index < 0 || bundle.length - index - signatureOrMessage.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH < 0) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_INDEX);
    }
    var bundleCopy = bundle.slice();
    var numberOfFragmentsToAdd = signatureOrMessage.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
    for (var i = 0; i < numberOfFragmentsToAdd; i++) {
        bundleCopy.set(signatureOrMessage.slice(i * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH, (i + 1) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH), (index + i) * transaction_1.TRANSACTION_LENGTH + transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
    }
    return bundleCopy;
};
exports.valueSum = function (buffer, offset, length) {
    if (!transaction_1.isMultipleOfTransactionLength(buffer.length)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_BUFFER_LENGTH);
    }
    if (!Number.isInteger(offset)) {
        throw new TypeError(errors.ILLEGAL_TRANSACTION_OFFSET);
    }
    if (!transaction_1.isMultipleOfTransactionLength(offset)) {
        throw new RangeError(errors.ILLEGAL_TRANSACTION_OFFSET);
    }
    if (!Number.isInteger(length)) {
        throw new TypeError(errors.ILLEGAL_BUNDLE_LENGTH);
    }
    if (!transaction_1.isMultipleOfTransactionLength(length)) {
        throw new RangeError(errors.ILLEGAL_BUNDLE_LENGTH);
    }
    var sum = 0;
    for (var bundleOffset = 0; bundleOffset < length; bundleOffset += transaction_1.TRANSACTION_LENGTH) {
        sum += converter_1.tritsToValue(transaction_1.value(buffer, offset + bundleOffset));
    }
    return sum;
};
//# sourceMappingURL=index.js.map