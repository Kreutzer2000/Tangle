import * as Promise from 'bluebird';
import '../../typed-array';
import { NativeGenerateSignatureFunction } from '../../types';
export declare const MIN_TRYTE_VALUE = -13;
export declare const MAX_TRYTE_VALUE = 13;
export declare const NUMBER_OF_SECURITY_LEVELS = 3;
export declare const HASH_LENGTH = 243;
export declare const FRAGMENT_LENGTH: number;
export declare const NUMBER_OF_FRAGMENT_CHUNKS: number;
export declare const NORMALIZED_FRAGMENT_LENGTH: number;
/**
 * This method derives a subseed from a seed and a private key index.
 *
 * You can use the subseed to [derive private keys and their addresses](https://docs.iota.org/docs/client-libraries/0.1/how-to-guides/js/derive-addresses-from-private-keys).
 *
 * **Note:** If the given seed is less then 243 trits, 0 trits are appended to it until it is 243 trits long.
 *
 * ## Related methods
 *
 * To convert a seed from trytes to trits, use the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * To derive a private key from the subseed, use the [`key()`]{@link #module_signing.key} method.
 *
 * @method subseed
 *
 * @summary Generates a subseed.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} seed - A 243-trit seed to use to derive the subseed
 * @param {number} index - The private key index to use to derive the subseed
 *
 * @example
 * ```js
 * const seed = 'MYSUPERSECRETSEED...';
 * const subseed = Sign.subseed(Converter.trytesToTrits(seed), 0);
 * ```
 *
 * @return {Int8Array} subseed - A subseed in trits
 *
 * @throws {errors.ILLEGAL_SUBSEED_INDEX}: Make sure that the `index` argument is a number greater than 0.
 */
export declare function subseed(seed: Int8Array, index: number): Int8Array;
/**
 * This method derives a private key from a subseed.
 *
 * You can use the private key to [derive an address](https://docs.iota.org/docs/client-libraries/0.1/how-to-guides/js/derive-addresses-from-private-keys) and to sign bundles that withdraw from that address.
 *
 * ## Related methods
 *
 * To generate a subseed, use the [`subseed()`]{@link #module_signing.subseed} method.
 *
 * @method key
 *
 * @summary Generates a private key.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} subseedTrits - A subseed in trits
 * @param {number} numberOfFragments - The security level that you want the private key to have
 *
 * @example
 * ```js
 * const seed = 'MYSUPERSECRETSEED...';
 * const subseed = Signing.subseed(Converter.trytesToTrits(seed), 0);
 *
 * const privateKey = Signing.key(subseed, 2);
 * ```
 *
 * @return {Int8Array} privateKey - A private key in trits.
 *
 * @throws {errors.ILLEGAL_SUBSEED_LENGTH}: Make sure that the `subseedTrits` argument contains 243 trits.
 * @throws {errors.ILLEGAL_NUMBER_OF_FRAGMENTS}: Make sure that the `numberOfFragments` argument is a valid security level (between 1 and 3).
 */
export declare function key(subseedTrits: Int8Array, numberOfFragments: number): Int8Array;
/**
 * This method derives key digests from a private key.
 *
 * You can use the key digests to [generate an address](https://docs.iota.org/docs/client-libraries/0.1/how-to-guides/js/derive-addresses-from-private-keys).
 *
 * ## Related methods
 *
 * To generate a private key, use the [`key()`]{@link #module_signing.key} method.
 *
 * @method digests
 *
 * @summary Generates key digests for a given private key.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} key - Private key in trits
 *
 * @example
 * ```js
 * const seed = 'MYSUPERSECRETSEED...';
 * const subseed = Signing.subseed(Converter.trytesToTrits(seed), 0);
 *
 * const privateKey = Signing.key(subseed, 2);
 *
 * const digests = Signing.digests(privateKey);
 * ```
 *
 * @return {Int8Array} digests - Key digests in trits
 *
 * @throws {errors.ILLEGAL_KEY_LENGTH}: Make sure that the `key` argument contains 2,187, 4,374, or 6,561 trits.
 */
export declare function digests(key: Int8Array): Int8Array;
/**
 * This method derives a 243-trit address from the given key digests.
 *
 * ## Related methods
 *
 * To generate a private key, use the [`key()`]{@link #module_signing.key} method.
 *
 * @method address
 *
 * @summary Derives an address from the given key digests.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} digests - Key digests in trits
 *
 * @example
 * ```js
 * const seed = 'MYSUPERSECRETSEED...';
 * const subseed = Signing.subseed(Converter.trytesToTrits(seed), 0);
 *
 * const privateKey = Signing.key(subseed, 2);
 *
 * const digests = Signing.digests(privateKey);
 *
 * const address = Signing.address(digests);
 * ```
 *
 * @return {Int8Array} address - Address in trits
 *
 * @throws {errors.ILLEGAL_DIGESTS_LENGTH}: Make sure that the `digests` argument contains a multiple of 243 trits.
 */
export declare function address(digests: Int8Array): Int8Array;
/**
 * @method digest
 *
 * @ignore
 *
 * @param {array} normalizedBundleFragment - Normalized bundle fragments in trits
 * @param {Int8Array} signatureFragment - Signature fragment trits
 *
 * @return {Int8Array} Digest trits
 */
export declare function digest(normalizedBundleFragment: Int8Array, signatureFragment: Int8Array, // tslint:disable-line
normalizedBundleFragmentOffset?: number, signatureFragmentOffset?: number): Int8Array;
/**
 * @method signatureFragment
 * @ignore
 * @param {array} normalizeBundleFragment - normalized bundle fragment
 * @param {keyFragment} keyFragment - key fragment trits
 *
 * @return {Int8Array} Signature Fragment trits
 */
export declare function signatureFragment(normalizedBundleFragment: Int8Array, keyFragment: Int8Array, normalizedBundleFragmentOffset?: number, keyFragmentOffset?: number): Int8Array;
export declare function signatureFragments(seed: Int8Array, index: number, numberOfFragments: number, bundle: Int8Array, nativeGenerateSignatureFunction?: NativeGenerateSignatureFunction): Promise<Int8Array>;
/**
 * This method validates a signature by doing the following:
 *
 * - Normalizing the bundle hash
 * - Deriving the key digests of the address, using the normalized bundle hash and the signature
 * -.Deriving an address from the key digests
 * - Comparing the derived address to the `expectedAddress` argument to find out if they match
 *
 * If the addresses match, the signature is valid.
 *
 * For more information about signatures see the [documentation portal](https://docs.iota.org/docs/getting-started/0.1/clients/signatures).
 *
 * ## Related methods
 *
 * To convert trytes such as bundle hashes and addresses to trits, use the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method validateSignatures
 *
 * @summary Validates the given signature, using the given bundle and address.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} expectedAddress - Input address in trits
 * @param {Array<Int8Array>} signatureFragments - Signature fragments in trits
 * @param {Int8Array} bundle - Bundle hash in trits
 *
 * @example
 * ```js
 * let valid = Signing.validateSignatures(expectedAddress, signatureFragments, bundle);
 * ```
 *
 * @return {boolean} valid - Whether the signatures are valid.
 *
 * @throws {errors.ILLEGAL_BUNDLE_HASH_LENGTH}: Make sure that the `bundle` argument contains a 243-trit bundle hash.
 */
export declare function validateSignatures(expectedAddress: Int8Array, signatureFragments: ReadonlyArray<Int8Array>, // tslint:disable-line
bundle: Int8Array): boolean;
/**
 * This method normalizes the given bundle hash to make sure that only around half of the private key is revealed when the bundle hash is signed.
 *
 * For more information about signatures see the [documentation portal](https://docs.iota.org/docs/getting-started/0.1/clients/signatures).
 *
 * To find out more about why the bundle hash is normalized, see [this answer on StackExchange](https://iota.stackexchange.com/questions/1588/why-is-the-bundle-hash-normalized).
 *
 * ## Related methods
 *
 * To convert a bundle hash from trytes to trits, use the [`trytesToTrits()`]{@link #module_converter.trytesToTrits} method.
 *
 * @method normalizedBundle
 *
 * @summary Normalizes the bundle hash.
 *
 * @memberof module:signing
 *
 * @param {Int8Array} bundle - Bundle hash in trits
 *
 * @example
 * ```js
 * let normalizedBundleHash = Signing.normalizedBundle(bundle);
 * ```
 *
 * @return {Int8Array} Normalized bundle hash in trits
 *
 * @throws {errors.ILLEGAL_BUNDLE_HASH_LENGTH}: Make sure that the `bundle` argument contains a 243-trit bundle hash.
 */
export declare const normalizedBundle: (bundle: Int8Array) => Int8Array;
