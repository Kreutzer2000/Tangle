"use strict";
// Copyright 2023 IOTA Stiftung
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.migrateDbChrysalisToStardust = exports.migrateStrongholdSnapshotV2ToV3 = exports.listenMqtt = exports.getSecretManagerFromWallet = exports.getClientFromWallet = exports.listenWalletAsync = exports.destroyWallet = exports.callWalletMethodAsync = exports.callUtilsMethod = exports.callSecretManagerMethodAsync = exports.callClientMethodAsync = exports.createWallet = exports.createSecretManager = exports.destroyClient = exports.createClient = exports.initLogger = void 0;
const wallet_1 = require("./types/wallet");
// @ts-ignore: path is set to match runtime transpiled js path
const addon = require("../build/Release/index.node");
const { callUtilsMethodRust, callSecretManagerMethod, createSecretManager, initLogger, callClientMethod, createClient, destroyClient, listenMqtt, callWalletMethod, createWallet, listenWallet, destroyWallet, getClientFromWallet, getSecretManagerFromWallet, migrateStrongholdSnapshotV2ToV3, migrateDbChrysalisToStardust, } = addon;
exports.createSecretManager = createSecretManager;
exports.initLogger = initLogger;
exports.createClient = createClient;
exports.destroyClient = destroyClient;
exports.listenMqtt = listenMqtt;
exports.createWallet = createWallet;
exports.destroyWallet = destroyWallet;
exports.getClientFromWallet = getClientFromWallet;
exports.getSecretManagerFromWallet = getSecretManagerFromWallet;
exports.migrateStrongholdSnapshotV2ToV3 = migrateStrongholdSnapshotV2ToV3;
exports.migrateDbChrysalisToStardust = migrateDbChrysalisToStardust;
const callClientMethodAsync = (method, handler) => new Promise((resolve, reject) => {
    callClientMethod(method, handler, (error, result) => {
        if (error) {
            reject(error);
        }
        else {
            resolve(result);
        }
    });
});
exports.callClientMethodAsync = callClientMethodAsync;
const callSecretManagerMethodAsync = (method, handler) => new Promise((resolve, reject) => {
    callSecretManagerMethod(method, handler, (error, result) => {
        if (error) {
            reject(error);
        }
        else {
            resolve(result);
        }
    });
});
exports.callSecretManagerMethodAsync = callSecretManagerMethodAsync;
const callUtilsMethod = (method) => {
    const response = JSON.parse(callUtilsMethodRust(JSON.stringify(method)));
    if (response.type == 'error' || response.type == 'panic') {
        throw response;
    }
    else {
        return response.payload;
    }
};
exports.callUtilsMethod = callUtilsMethod;
const listenWalletAsync = (eventTypes, callback, handler) => {
    listenWallet(eventTypes, function (err, data) {
        const parsed = JSON.parse(data);
        callback(err, new wallet_1.Event(parsed.accountIndex, parsed.event));
    }, handler);
    return Promise.resolve();
};
exports.listenWalletAsync = listenWalletAsync;
const callWalletMethodAsync = (method, handler) => new Promise((resolve, reject) => {
    callWalletMethod(method, handler, (error, result) => {
        if (error) {
            reject(error);
        }
        else {
            resolve(result);
        }
    });
});
exports.callWalletMethodAsync = callWalletMethodAsync;
//# sourceMappingURL=bindings.js.map