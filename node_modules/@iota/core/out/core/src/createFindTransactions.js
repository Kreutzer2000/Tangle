"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var checksum_1 = require("@iota/checksum");
var converter_1 = require("@iota/converter");
var pad_1 = require("@iota/pad");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var keysOf = function (o) { return Object.keys(o); };
var validKeys = ['bundles', 'addresses', 'tags', 'approvees'];
var hasValidKeys = function (query) {
    for (var _i = 0, _a = keysOf(query); _i < _a.length; _i++) {
        var key = _a[_i];
        if (validKeys.indexOf(key) === -1) {
            throw new Error(errors.INVALID_SEARCH_KEY + ": " + key);
        }
    }
};
exports.validateFindTransactions = function (query) {
    var addresses = query.addresses, approvees = query.approvees, bundles = query.bundles, tags = query.tags;
    hasValidKeys(query);
    guards_1.validate(!!addresses && [addresses, function (arr) { return arr.every(guards_1.isHash); }, errors.INVALID_ADDRESS], !!tags && [tags, function (arr) { return arr.every(guards_1.isTag); }, errors.INVALID_TAG], !!approvees && [
        approvees,
        function (arr) { return arr.every(function (a) { return guards_1.isTrytesOfExactLength(a, transaction_1.TRANSACTION_HASH_LENGTH / converter_1.TRYTE_WIDTH); }); },
        errors.INVALID_TRANSACTION_HASH,
    ], !!bundles && [
        bundles,
        function (arr) { return arr.every(function (b) { return guards_1.isTrytesOfExactLength(b, transaction_1.BUNDLE_LENGTH / converter_1.TRYTE_WIDTH); }); },
        errors.INVALID_HASH,
    ]);
};
exports.removeAddressChecksum = function (query) {
    return query.addresses
        ? __assign({}, query, { addresses: query.addresses.map(checksum_1.removeChecksum) }) : query;
};
exports.padTags = function (query) {
    return query.tags
        ? __assign({}, query, { tags: pad_1.padTagArray(query.tags) }) : query;
};
/**
 * @method createFindTransactions
 *
 * @summary Creates a new `findTransactions()` method, using a custom Provider instance.
 *
 * @memberof module:core
 *
 * @ignore
 *
 * @param {Provider} provider - The Provider object that the method should use to call the node's API endpoints.
 *
 * @return {Function} [`findTransactions`]{@link #module_core.findTransactions}  - A new `findTransactions()` function that uses your chosen Provider instance.
 */
exports.createFindTransactions = function (_a) {
    var send = _a.send;
    /**
     * This method searches for transaction hashes by calling the connected IRI node's [`findTransactions`](https://docs.iota.org/docs/node-software/0.1/iri/references/api-reference#findTransactions) endpoint.
     *
     * If you pass more than one query parameter, this method returns only transactions that contain all the given fields in those queries.
     *
     * ## Related methods
     *
     * To find transaction objects, use the [`findTransactionObjects()`]{@link #module_core.findTransactionObjects} method.
     *
     * @method findTransactions
     *
     * @summary * Searches the Tangle for the hashes of transactions that contain all the given values in their transaction fields.
     *
     * @memberof module:core
     *
     * @param {Object} query - Query object
     * @param {Hash[]} [query.addresses] - Array of addresses to search for in transactions
     * @param {Hash[]} [query.bundles] - Array of bundle hashes to search for in transactions
     * @param {Tag[]} [query.tags] - Array of tags to search for in transactions
     * @param {Hash[]} [query.approvees] - Array of transaction hashes that you want to search for in transactions' branch and trunk transaction fields
     * @param {Callback} [callback] - Optional callback function
     *
     * @example
     *
     * ```js
     * findTransactions({ addresses: ['ADDRESS999...'] })
     *    .then(transactionHashes => {
     *      console.log(`Successfully found the following transactions:)
     *      console.log(JSON.stringify(transactionHashes));
     *   })
     *   .catch(error => {
     *     console.log(`Something went wrong: ${error}`)
     *   })
     * ```
     *
     * @returns {Promise}
     *
     * @fulfil {Hash[]} transactionHashes - Array of transaction hashes for transactions, which contain fields that match the query object
     *
     * @reject {Error} error - An error that contains one of the following:
     * - `INVALID_SEARCH_KEY`: Make sure that you entered valid query parameters
     * - `INVALID_HASH`: Make sure that the bundle hashes are 81 trytes long
     * - `INVALID_TRANSACTION_HASH`: Make sure that the approvee transaction hashes are 81 trytes long
     * - `INVALID_ADDRESS`: Make sure that the addresses contain only trytes
     * - `INVALID_TAG`: Make sure that the tags contain only trytes
     * - Fetch error: The connected IOTA node's API returned an error. See the [list of error messages](https://docs.iota.org/docs/node-software/0.1/iri/references/api-errors)
     */
    return function findTransactions(query, callback) {
        return Promise.resolve(exports.validateFindTransactions(query))
            .then(function () { return exports.removeAddressChecksum(query); })
            .then(exports.padTags)
            .then(function (formattedQuery) {
            return send(__assign({}, formattedQuery, { command: types_1.IRICommand.FIND_TRANSACTIONS }));
        })
            .then(function (_a) {
            var hashes = _a.hashes;
            return hashes;
        })
            .asCallback(callback);
    };
};
//# sourceMappingURL=createFindTransactions.js.map