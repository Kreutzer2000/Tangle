"use strict";
exports.__esModule = true;
var converter_1 = require("@iota/converter");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
/**
 * @method createAttachToTangle
 *
 * @summary Creates a new `attachToTangle()` method, using a custom Provider instance.
 *
 * @memberof module:core
 *
 * @ignore
 *
 * @param {Provider} provider - The Provider object that the method should use to call the node's API endpoints.
 *
 * @return {Function} [`attachToTangle`]{@link #module_core.attachToTangle} - A new `attachToTangle()` function that uses your chosen Provider instance.
 */
exports.createAttachToTangle = function (_a) {
    var send = _a.send;
    /**
     * This method uses the connected IRI node's [`attachToTangle`](https://docs.iota.org/docs/node-software/0.1/iri/references/api-reference#attachToTangle) endpoint to chain the given transaction trytes into a bundle and do proof of work.
     *
     * By doing proof of work, this method overwrites the following transaction fields:
     *  - `hash`
     *  - `nonce`
     *  - `attachmentTimestamp`
     *  - `attachmentTimestampLowerBound`
     *  - `attachmentTimestampUpperBound`
     *
     * **Note:** You can replace this method with your own custom one in the [`composeApi()`]{@link ##module_core.composeApi} method. For example, you may want to write a function that does local proof of work, using either the [`ccurl.interface.js`](https://github.com/iotaledger/ccurl.interface.js) NodeJS library,
     * or the [`curl.lib.js`](https://github.com/iotaledger/curl.lib.js) library for browsers that support WebGL2.
     *
     * ## Related methods
     *
     * To attach the returned transaction trytes to the Tangle, use the [`broadcastTransactions()`]{@link #module_core.broadcastTransactions} method to send them to a node.
     *
     * You can get a trunk and branch transaction hash by calling the
     * [`getTransactionsToApprove()`]{@link #module_core.getTransactionsToApprove} method
     *
     * @method attachToTangle
     *
     * @summary Connects the given transaction trytes into a bundle and sends them to the connected IOTA node to complete [remote proof of work](https://docs.iota.org/docs/getting-started/0.1/transactions/proof-of-work).
     *
     * @memberof module:core
     *
     * @param {Hash} trunkTransaction - Trunk transaction hash
     * @param {Hash} branchTransaction - Branch transaction hash
     * @param {number} minWeightMagnitude - The [minimum weight magnitude](https://docs.iota.org/docs/getting-started/0.1/network/minimum-weight-magnitude) to use for proof of work. **Note:** This value must be at least the same as the minimum weight magnitude of the branch and trunk transactions.
     * @param {TransactionTrytes[]} trytes - Array of transaction trytes in head first order, which are returned by the [`prepareTransfers()`]{@link #module_core.prepareTransfers} method
     * @param {Callback} [callback] - Optional callback function
     *
     * @example
     *
     * ```js
     * getTransactionsToApprove(depth)
     *   .then(({ trunkTransaction, branchTransaction }) =>
     *     attachToTangle(trunkTransaction, branchTransaction, minWeightMagnitude, trytes)
     *   )
     *   .then(attachedTrytes => {
     *     console.log(`Successfully did proof of work. Here are your bundle's transaction trytes: ${attachedTrytes}`)
     *   }).catch(error => {
     *     console.log(`Something went wrong: ${error}`)
     *   })
     * ```
     *
     * @return {Promise}
     *
     * @fulfil {TransactionTrytes[]} attachedTrytes - Array of transaction trytes in tail-first order. To attach these transactions to the Tangle, pass the trytes to the [`broadcastTransactions()`]{@link #module_core.broadcastTransactions} method.
     *
     * @reject {Error} error - One of the following errors:
     * - `INVALID_TRUNK_TRANSACTION`: Make sure that the hash contains 81 trytes
     * - `INVALID_BRANCH_TRANSACTION`: Make sure that the hash contains 81 trytes
     * - `INVALID_MIN_WEIGHT_MAGNITUDE`: Make sure that the minimum weight magnitude is at least the same as the one used for the branch and trunk transactions.
     * - `INVALID_TRANSACTION_TRYTES`: Make sure the trytes can be converted to a valid transaction object
     * - Fetch error: The connected IOTA node's API returned an error. See the [list of error messages](https://docs.iota.org/docs/node-software/0.1/iri/references/api-errors)
     */
    return function attachToTangle(trunkTransaction, branchTransaction, minWeightMagnitude, trytes, callback) {
        return Promise.resolve(guards_1.validate([
            trunkTransaction,
            function (t) { return guards_1.isTrytesOfExactLength(t, transaction_1.TRANSACTION_HASH_LENGTH / converter_1.TRYTE_WIDTH); },
            errors.INVALID_TRUNK_TRANSACTION,
        ], [
            branchTransaction,
            function (t) { return guards_1.isTrytesOfExactLength(t, transaction_1.TRANSACTION_HASH_LENGTH / converter_1.TRYTE_WIDTH); },
            errors.INVALID_BRANCH_TRANSACTION,
        ], [
            minWeightMagnitude,
            function (mwm) { return Number.isInteger(mwm) && mwm <= transaction_1.TRANSACTION_HASH_LENGTH; },
            errors.INVALID_MIN_WEIGHT_MAGNITUDE,
        ], [
            trytes,
            function (arr) {
                return arr.every(function (t) {
                    return guards_1.isTrytesOfExactLength(t, transaction_1.TRANSACTION_LENGTH / converter_1.TRYTE_WIDTH) &&
                        transaction_1.isTransaction(converter_1.trytesToTrits(t));
                });
            },
            errors.INVALID_TRANSACTION_TRYTES,
        ]))
            .then(function () {
            return send({
                command: types_1.IRICommand.ATTACH_TO_TANGLE,
                trunkTransaction: trunkTransaction,
                branchTransaction: branchTransaction,
                minWeightMagnitude: minWeightMagnitude,
                trytes: trytes
            });
        })
            .then(function (res) { return res.trytes; })
            .asCallback(typeof arguments[2] === 'function' ? arguments[2] : callback);
    };
};
//# sourceMappingURL=createAttachToTangle.js.map