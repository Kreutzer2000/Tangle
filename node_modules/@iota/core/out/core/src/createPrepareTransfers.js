"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
exports.__esModule = true;
var bundle_1 = require("@iota/bundle");
var checksum_1 = require("@iota/checksum");
var converter_1 = require("@iota/converter");
var signing_1 = require("@iota/signing");
var transaction_1 = require("@iota/transaction");
var Promise = require("bluebird");
var errors = require("../../errors");
var guards_1 = require("../../guards");
var types_1 = require("../../types");
var utils_1 = require("../../utils");
var _1 = require("./");
var hmac_1 = require("./hmac");
var HASH_LENGTH = 81;
var NULL_HASH_TRYTES = '9'.repeat(HASH_LENGTH);
var SECURITY_LEVEL = 2;
var defaults = {
    inputs: [],
    address: undefined,
    remainderAddress: undefined,
    security: 2,
    hmacKey: undefined
};
var isTritArray = function (tritArray, length) {
    return (tritArray instanceof Array || tritArray instanceof Int8Array) &&
        typeof tritArray.every === 'function' &&
        tritArray.every(function (trit) { return [-1, 0, 1].indexOf(trit) > -1; }) &&
        (typeof length === 'number' ? tritArray.length === length : true);
};
exports.getPrepareTransfersOptions = function (options) { return (__assign({}, types_1.getOptionsWithDefaults(defaults)(options), { remainderAddress: options.address || options.remainderAddress || undefined })); };
/**
 *
 * @method createPrepareTransfers
 *
 * @summary Creates a new `prepareTransfers()` method.
 *
 * @memberof module:core
 *
 * @param {Provider} [provider] - Optional provider object that the method should use to call the node's API endpoints.
 * To create transactions offline, omit this parameter so that the returned function does not get your addresses and balances from the node. To create value transactions offline, make sure to pass input objects and a remainder address to the returned function.
 *
 * @example
 * ```js
 * const prepareTransfers = Iota.createPrepareTransfers();
 *
 * const transfers = [
 *  {
 *    value: 1,
 *    address: 'RECEIVINGADDRESS...'
 *  }
 * ];
 *
 * prepareTransfers(seed, transfers, {
 *  inputs:[{address: 'ADDRESS...',
 *  keyIndex: 5,
 *  security: 2,
 *  balance: 50}],
 *  // Remainder will be 50 -1 = 49 IOTA tokens
 *  address: 'REMAINDERADDRESS...'
 * })
 * .then(bundleTrytes => {
 *  console.log('Bundle trytes are ready to be attached to the Tangle:');
 *  console.log(JSON.stringify(bundleTrytes));
 * })
 * .catch(error => {
 *  console.log(`Something went wrong: ${error}`);
 * });
 * ```
 *
 * @return {Function} [`prepareTransfers`]{@link #module_core.prepareTransfers}  - A new `prepareTransfers()` function that uses your chosen Provider instance.
 */
exports.createPrepareTransfers = function (provider, now, caller) {
    if (now === void 0) { now = function () { return Date.now(); }; }
    var addInputs = exports.createAddInputs(provider);
    var addRemainder = exports.createAddRemainder(provider);
    /**
     * This method creates a bundle, using the given arguments and uses the given seed to sign any transactions that withdraw IOTA tokens.
     *
     * **Note:** The given seed is used to [generate addresses](https://docs.iota.org/docs/client-libraries/0.1/how-to-guides/js/generate-an-address) and sign transactions on your local device. It is never sent anywhere.
     *
     * **Note:** To create transactions offline, use the [`createPrepareTransfers`]{@link #module_core.createPrepareTransfers} without a `provider` argument.
     *
     * After calling this method, we recommend saving the returned transaction trytes in local storage before sending them to a node.
     * By doing so, you make sure that you can always reattach your transactions to the Tangle in case they remain in a pending state.
     * Reattaching transactions is safer than creating and signing new transactions, which could lead to [spent addresses](https://docs.iota.org/docs/getting-started/0.1/clients/addresses#spent-addresses).
     *
     * ## Related methods
     *
     * To attach the returned transaction trytes to the Tangle, you can use one of the following:
     *
     * - [`sendTrytes()`]{@link #module_core.sendTrytes} (easiest)
     * - [`getTransactionsToApprove()`]{@link #module_core.getTransactionsToApprove} followed by [`attachToTangle()`]{@link #module_core.attachToTangle} followed by [`broadcastTransactions()`]{@link #module_core.broadcastTransactions} (for more control)
     *
     * @method prepareTransfers
     *
     * @summary Creates and signs a bundle of valid transaction trytes, using the given arguments.
     *
     * @memberof module:core
     *
     * @param {string} seed - The seed to use to generate addresses and sign transactions
     *
     * @param {Transfers.<Transfer>} transfers - Array of transfer objects
     * @param {Hash} transfer.address - Address to which to send a transaction
     * @param {number} transfer.value - Amount of IOTA tokens to send to the address
     * @param {string} transfer.message - Message to include in the transaction. The message must include only ASCII characters.
     * @param {string} transfer.tag - Up to 27 trytes to include in the transaction's `obsoleteTag` field
     * @param {Object} [options] - Options object
     * @param {Input[]} [options.inputs] Array of input objects, which contain information about the addresses from which to withdraw IOTA tokens
     * @param {Hash} [options.inputs[].address] One of the seed's addresses from which to withdraw IOTA tokens
     * @param {number} [options.inputs[].keyIndex] Key index of the address
     * @param {number} [options.inputs[].security] Security level of the address
     * @param {number} [options.inputs[].balance] Total balance of the address. The total balance is withdrawn and any remaining IOTA tokens are sent to the address in the `options.remainderAddress` field.
     * @param {Hash} [options.remainderAddress] Remainder address to send any remaining IOTA tokens (total value in the `transfers` array minus the total balance of the input addresses)
     * @param {number} [options.security=2] Security level to use for calling the [`getInputs`]{@link #module_core.getInputs} method to automatically select input objects
     * @property {Hash} [options.hmacKey] HMAC key used for adding an HMAC signature to the transaction
     *
     * @param {function} [callback] Optional callback function
     *
     * @example
     *
     * ```js
     *
     * const transfers = [
     *  {
     *    value: 1,
     *    address: 'RECEIVINGADDRESS...'
     *  }
     * ];
     *
     * prepareTransfers(seed, transfers)
     * .then(bundleTrytes => {
     *  console.log('Bundle trytes are ready to be attached to the Tangle:');
     *  console.log(JSON.stringify(bundleTrytes));
     * })
     * .catch(error => {
     *  console.log(`Something went wrong: ${error}`);
     * });
     * ```
     *
     * @return {Promise}
     *
     * @fulfil {array} bundleTrytes - Array of transaction trytes
     *
     * @reject {Error} error - An error that contains one of the following:
     * - `INVALID_SEED`: Make sure that the seed contains only trytes
     * - `INVALID_TRANSFER_ARRAY`: Make sure that any objects in the `transfers` argument are valid (for example that the addresses contain only trytes, the values are numbers)
     * - `INVALID_INPUT`: Make sure that the `options.inputs[]` argument contains valid input objects
     * - `INVALID_REMAINDER_ADDRESS`: If you used the `createPrepareTransfers()` method without a provider, make sure you entered an address in the `options.remainderAddress` argument
     * - `INSUFFICIENT_BALANCE`: Make sure that the seed's addresses have enough IOTA tokens to complete the transfer
     * - `NO_INPUTS`: Make sure that the `options.inputs[]` argument contains valid input objects
     * - `SENDING_BACK_TO_INPUTS`: Make sure that none of the `transfer.address` arguments are in the `options.inputs[].address parameters
     * - Fetch error: The connected IOTA node's API returned an error. See the [list of error messages](https://docs.iota.org/docs/node-software/0.1/iri/references/api-errors)
     */
    return function prepareTransfers(seed, transfers, options, callback) {
        if (options === void 0) { options = {}; }
        if (caller !== 'lib') {
            if (options.address) {
                /* tslint:disable-next-line:no-console */
                console.warn('`options.address` is deprecated and will be removed in v2.0.0. Use `options.remainderAddress` instead.');
            }
            if (typeof seed === 'string' ? guards_1.isTrytes(seed) && seed.length < 81 : isTritArray(seed) && seed.length < 243) {
                /* tslint:disable-next-line:no-console */
                console.warn('WARNING: Seeds that are less than 81 trytes long are not secure! Generate a random, 81-trytes seed!');
            }
        }
        if (!guards_1.isTrytes(seed) && !isTritArray(seed)) {
            throw new Error(errors.INVALID_SEED);
        }
        var props = Promise.resolve(exports.validatePrepareTransfers(__assign({ transactions: new Int8Array(0), trytes: [], seed: typeof seed === 'string' ? converter_1.trytesToTrits(seed) : new Int8Array(seed), transfers: transfers, timestamp: Math.floor((typeof now === 'function' ? now() : Date.now()) / 1000) }, exports.getPrepareTransfersOptions(options))));
        return utils_1.asyncPipe(exports.addHMACPlaceholder, exports.addTransfers, addInputs, addRemainder, exports.verifyNotSendingToInputs, exports.finalize, exports.addSignatures, exports.addHMAC, exports.asTransactionTrytes)(props)
            .then(function (res) { return res.trytes; })
            .asCallback(callback);
    };
};
exports.validatePrepareTransfers = function (props) {
    var transfers = props.transfers, inputs = props.inputs, security = props.security;
    var remainderAddress = props.address || props.remainderAddress;
    guards_1.validate(guards_1.securityLevelValidator(security), guards_1.arrayValidator(guards_1.transferValidator)(transfers), !!remainderAddress && guards_1.remainderAddressValidator(remainderAddress), inputs.length > 0 && guards_1.arrayValidator(guards_1.inputValidator)(inputs));
    return props;
};
exports.addHMACPlaceholder = function (props) {
    var hmacKey = props.hmacKey, transfers = props.transfers;
    return hmacKey
        ? __assign({}, props, { transfers: transfers.map(function (transfer, i) {
                return transfer.value > 0
                    ? __assign({}, transfer, { message: NULL_HASH_TRYTES + (transfer.message || '') }) : transfer;
            }) }) : props;
};
exports.addTransfers = function (props) {
    var transactions = props.transactions, transfers = props.transfers, timestamp = props.timestamp;
    return __assign({}, props, { transactions: transfers.reduce(function (acc, transfer) {
            var messageTrits = converter_1.trytesToTrits(transfer.message || '');
            var signatureOrMessage = new Int8Array((1 + Math.floor(messageTrits.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH)) * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH);
            signatureOrMessage.set(messageTrits, transaction_1.SIGNATURE_OR_MESSAGE_OFFSET);
            return bundle_1.addEntry(acc, {
                signatureOrMessage: signatureOrMessage,
                address: converter_1.trytesToTrits(checksum_1.removeChecksum(transfer.address)),
                value: converter_1.valueToTrits(transfer.value),
                obsoleteTag: converter_1.trytesToTrits(transfer.tag || ''),
                issuanceTimestamp: converter_1.valueToTrits(timestamp),
                tag: converter_1.trytesToTrits(transfer.tag || '')
            });
        }, transactions) });
};
exports.createAddInputs = function (provider) {
    var getInputs = provider ? _1.createGetInputs(provider) : undefined;
    return function (props) {
        var transactions = props.transactions, transfers = props.transfers, inputs = props.inputs, timestamp = props.timestamp, seed = props.seed, security = props.security;
        var threshold = transfers.reduce(function (sum, transfer) { return (sum += transfer.value); }, 0);
        if (threshold === 0) {
            return Promise.resolve(props);
        }
        if (inputs.length && threshold > inputs.reduce(function (acc, input) { return (acc += input.balance); }, 0)) {
            throw new Error(inputs.length ? errors.INSUFFICIENT_BALANCE : errors.NO_INPUTS);
        }
        return (!getInputs || inputs.length
            ? Promise.resolve(inputs)
            : getInputs(converter_1.tritsToTrytes(seed), { security: security, threshold: threshold }).then(function (response) { return response.inputs; })).then(function (res) { return (__assign({}, props, { inputs: res, transactions: res.reduce(function (acc, input) {
                return bundle_1.addEntry(acc, {
                    signatureOrMessage: new Int8Array(input.security * transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
                    address: converter_1.trytesToTrits(checksum_1.removeChecksum(input.address)),
                    value: converter_1.valueToTrits(-input.balance),
                    issuanceTimestamp: converter_1.valueToTrits(timestamp)
                });
            }, transactions) })); });
    };
};
exports.createAddRemainder = function (provider) {
    var getNewAddress = provider ? _1.createGetNewAddress(provider, 'lib') : undefined;
    return function (props) {
        var transactions = props.transactions, remainderAddress = props.remainderAddress, seed = props.seed, security = props.security, inputs = props.inputs, timestamp = props.timestamp;
        // Values of transactions in the bundle should sum up to 0.
        var sum = bundle_1.valueSum(transactions, 0, transactions.length);
        // Value > 0 indicates insufficient balance in inputs.
        if (sum > 0) {
            throw new Error(errors.INSUFFICIENT_BALANCE);
        }
        // If value is already zero no remainder is required
        if (sum === 0) {
            return props;
        }
        if (!provider && !remainderAddress) {
            throw new Error(errors.INVALID_REMAINDER_ADDRESS);
        }
        return (remainderAddress
            ? Promise.resolve(remainderAddress)
            : getNewAddress(converter_1.tritsToTrytes(seed), {
                index: exports.getRemainderAddressStartIndex(inputs),
                security: security
            })).then(function (addresses) {
            var addressTrytes = types_1.asArray(addresses)[0];
            return __assign({}, props, { remainderAddress: addressTrytes, transactions: bundle_1.addEntry(transactions, {
                    signatureOrMessage: new Int8Array(transaction_1.SIGNATURE_OR_MESSAGE_LENGTH),
                    address: converter_1.trytesToTrits(addressTrytes),
                    value: converter_1.valueToTrits(Math.abs(sum)),
                    issuanceTimestamp: converter_1.valueToTrits(timestamp)
                }) });
        });
    };
};
exports.getRemainderAddressStartIndex = function (inputs) {
    return inputs.slice().sort(function (a, b) { return b.keyIndex - a.keyIndex; })[0].keyIndex + 1;
};
exports.verifyNotSendingToInputs = function (props) {
    var transactions = props.transactions;
    for (var offset = 0; offset < transactions.length; offset += transaction_1.TRANSACTION_LENGTH) {
        if (converter_1.tritsToValue(transaction_1.value(transactions, offset)) < 0) {
            for (var jOffset = 0; jOffset < transactions.length; jOffset += transaction_1.TRANSACTION_LENGTH) {
                if (jOffset !== offset) {
                    if (converter_1.tritsToValue(transaction_1.value(transactions, jOffset)) > 0 &&
                        converter_1.tritsToTrytes(transaction_1.address(transactions, jOffset)) === converter_1.tritsToTrytes(transaction_1.address(transactions, offset))) {
                        throw new Error(errors.SENDING_BACK_TO_INPUTS);
                    }
                }
            }
        }
    }
    return props;
};
exports.finalize = function (props) { return (__assign({}, props, { transactions: bundle_1.finalizeBundle(props.transactions) })); };
exports.addSignatures = function (props) {
    var transactions = props.transactions, inputs = props.inputs, seed = props.seed, nativeGenerateSignatureFunction = props.nativeGenerateSignatureFunction;
    var signatureIndex;
    for (var i = 0; i < transactions.length / transaction_1.TRANSACTION_LENGTH; i++) {
        if (converter_1.tritsToValue(transaction_1.value(transactions, i * transaction_1.TRANSACTION_LENGTH)) < 0) {
            signatureIndex = i;
            break;
        }
    }
    return Promise.all(inputs.map(function (_a) {
        var keyIndex = _a.keyIndex, security = _a.security;
        return signing_1.signatureFragments(seed, keyIndex, security || SECURITY_LEVEL, transaction_1.bundle(transactions), nativeGenerateSignatureFunction);
    })).then(function (signatures) { return (__assign({}, props, { transactions: signatures.reduce(function (acc, signature) {
            var transactionsCopy = bundle_1.addSignatureOrMessage(acc, signature, signatureIndex);
            signatureIndex += signature.length / transaction_1.SIGNATURE_OR_MESSAGE_LENGTH;
            return transactionsCopy;
        }, transactions) })); });
};
exports.addHMAC = function (props) {
    var hmacKey = props.hmacKey, transactions = props.transactions;
    return hmacKey ? __assign({}, props, { transactions: hmac_1["default"](transactions, converter_1.trytesToTrits(hmacKey)) }) : props;
};
exports.asTransactionTrytes = function (props) {
    var transactions = props.transactions;
    var trytes = [];
    for (var offset = 0; offset < transactions.length; offset += transaction_1.TRANSACTION_LENGTH) {
        trytes.push(converter_1.tritsToTrytes(transactions.subarray(offset, offset + transaction_1.TRANSACTION_LENGTH)));
    }
    return __assign({}, props, { trytes: trytes.reverse().slice() });
};
//# sourceMappingURL=createPrepareTransfers.js.map